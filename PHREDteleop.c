#pragma config(Hubs, S1, HTMotor, HTServo, none, none)
#pragma config(Motor,  mtr_S1_C1_1, motorRight, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2, motorLeft, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1, servo1, tServoNone)
#pragma config(Servo,  srvo_S1_C2_2, servo2, tServoNone)
//#pragma DebuggerWindows("Globals");

//#pragma config(Motor,  motorA, , tmotorNXT, openLoop, encoder)
//#pragma config(Motor,  motorB, , tmotorNXT, openLoop, encoder)
//#pragma config(Motor,  motorC, , tmotorNXT, openLoop, encoder)
//#pragma config(Sensor, S1, , sensorI2CMuxController)
//#pragma config(Servo,  srvo_S1_C2_3, servo3, tServoNone)
//#pragma config(Servo,  srvo_S1_C2_4, servo4, tServoNone)
//#pragma config(Servo,  srvo_S1_C2_5, servo5, tServoNone)
//#pragma config(Servo,  srvo_S1_C2_6, servo6, tServoNone)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"

const int deadZone = 10;

void initializeRobot(){
   // According to the supplied documentation using PID control will use the motor
   // encoders to help the robot to travel a straight line. Driving straight == Good!

	 nMotorPIDSpeedCtrl[motorD] = mtrSpeedReg;
	 nMotorPIDSpeedCtrl[motorE] = mtrSpeedReg;
   return;
}


// Tank mode uses both left and right joysticks to drive the robot.
//
void Tank(int y1, int y2){
/**
 ** PLEASE DO NOT CHANGE ANY CODE IN THIS METHOD
 **/

   int powLeft  = y1;
   int powRight = y2;

   // Scale the joystick values, -128 to 127, to a motor speed range, -100 to 100.
   powLeft  = round((100 * powLeft) / 128);
   powRight = round((100 * powRight) / 128);

   // Joysticks don't always rest at "0,0", so adjust
   // with an appropriately sized "deadzone"
   if(abs(powLeft)  < deadZone) powLeft = 0;
   if(abs(powRight) < deadZone) powRight = 0;

   motor[motorLeft]  =  powLeft;
   motor[motorRight] =  powRight;
}

// Arcade mode uses left joystick for forward and reverse, and
// the right joystick for turns.
//
void Arcade(int x, int y){
/**
 ** PLEASE DO NOT CHANGE ANY CODE IN THIS METHOD
 **/

   int powY = y;
   int powX = x;
   int powRight;
   int powLeft;

   // Scale the joystick values, -128 to 127, to a motor speed range, -100 to 100.
   //
   powX = round((100 * powX) / 128);
   powY = round((100 * powY) / 128);

   // Joysticks don't always rest at "0,0", so adjust
   // with an appropriately sized "deadzone"
   //
   if(abs(powX) < deadZone) powX = 0;
   if(abs(powY) < deadZone) powY = 0;

   // Adjust power values to drive arcade style using two joysticks
   //
   if (powY == 0){               //No forward/reverse power so turn in place,
	    powRight =  powX * 0.65;
      powLeft  = -powX * 0.65 ;
   }
   else if (powX < 0){           // Forward/reverse power so make sweeping turn as dictated by the magnitude of X
      powLeft = powY;            // Left motor not changed
      if(powY < 0)               // Right motor power reduced for right turn
         powRight = powY - powX; // Account for forward and reverse
      else
      	 powRight = powY + powX;
   }
   else{
      powRight = powY;           // Right motor not changed
      if(powY < 0)               // Left motor power reduced for left turn
         powLeft = powY + powX;  // Account for forward and reverse
      else
         powLeft = powY - powX;
   }


   // Create a power curve that is more forgiving at small JS values
   /* Works, but disabled because it needs some tuning.  Maybe later.
   if(powLeft < 0)
      powLeft = -100 * pow(powLeft/100,2);
   else
      powLeft = 100 * pow(powLeft/100,2);

   if(powRight < 0)
      powRight = -100 * pow(powRight/100,2);
   else
      powRight = 100 * pow(powRight/100,2);
   */

   // Apply power to the motors
   motor[motorLeft]  =  powLeft;
   motor[motorRight] =  powRight;
}

task main(){

   initializeRobot();

   waitForStart();

   while (true){
      getJoystickSettings(joystick);
      //Tank(joystick.joy1_y2, joystick.joy1_y1);
      Arcade(joystick.joy1_x2, joystick.joy1_y1);
   }
}
